***Clase 2 Introducci√≥n al computo***

Resumen Introducci√≥n al C√≥mputo

‚ÄúPrimera computadora‚Äù creada por los griegos, calcula la posici√≥n del sol, luna y algunas constelaciones.

En 1801, Telar de Jacquar, separa el resultado de la informacion que contiene las instrucciones.

Siglo XIX, Motor anal√≠tico de Babbage, haciendo uso del avances en mec√°nica (engranajes) de su √©poca logra separar instrucciones de calculo y realizar varios c√°lculos a la vez.

Finales siglo XIX, ENIAC (Eectronic Numerical Integrator and Computer) usaba sistema decimal. creada por Alan Turing y Alonso. Esta √©poca exig√≠a exactitud en los c√°lculos que hac√≠an que compa√±√≠as dependieran de esta(Compa√±√≠as Ferroviarias por ejemplo). Turing y Alonso, Descubrieron que matem√°ticamente todos los algoritmos pod√≠amos reducirlos a una secuencia de soluciones matem√°ticas.

En 1945, Arquitectura de Von Neumann, EDVAC (Electronic Discrete Variable Automatic Computer) usaba sistema binario. Su aporte fue el descubrimiento que dentro de los componentes electr√≥nicos se puede usar una serie de hadward para realizar el computo y almacenar datos dentro de memoria.

En 1950, Microchip, ejemplo Apple 1

En siglo XX, Arquitectura de Feymann, aporta las bases matem√°ticas de computo cu√°ntico.

- Las computadoras hacen dos cosas: hacen c√°lculos y recuerdan el resultado de dichos c√°lculos
- Por la mayor√≠a de la historia humana, est√°bamos limitados por la velocidad del cerebro y la mano
- A√∫n con las computadoras modernas existen problemas que no podemos resolver

***Clase 3 Introducci√≥n a los lenguajes de programaci√≥n***

Lenguajes:
- Tienen una sintaxis que definen la secuencia de s√≠mbolos que est√° bien formada
- Sem√°ntica est√°tica: Define qu√© enunciados con sintaxis correcta tienen significado
- Sem√°ntica: Define el significado, en los lenguajes de programaci√≥n solo hay un significado, son precisos, exactos, no tienen doble sentido

Un algoritmo es una lista finita de instrucciones que describen un c√≥mputo, que cuando se ejecuta con ciertas entradas(inputs) ejecuta
pasos intermedios para llegar  a un resultado (output)
- John V. Guttag

¬øQu√© es un lenguaje de programaci√≥n?
Es un lenguaje formal que, mediante una serie de instrucciones, le permite a un programador escribir un conjunto de √≥rdenes, acciones consecutivas, datos y algoritmos para, de esa forma, crear programas que controlen el comportamiento f√≠sico y l√≥gico de una m√°quina.

¬øQu√© tipos de lenguaje de programaci√≥n existen?
El lenguaje de programaci√≥n es la base para construir todas las aplicaciones digitales que se utilizan en el d√≠a a d√≠a y se clasifican en dos tipos principales: lenguaje de bajo nivel y de alto nivel.

Lenguaje de programaci√≥n de bajo nivel
Son lenguajes totalmente orientados a la m√°quina.

Este lenguaje sirve de interfaz y crea un v√≠nculo inseparable entre el hardware y el software.

Adem√°s, ejerce un control directo sobre el equipo y su estructura f√≠sica. Para aplicarlo adecuadamente es necesario que el programador conozca s√≥lidamente el hardware. √âste se subdivide en dos tipos:

Lenguaje m√°quina
Es el m√°s primitivo de los lenguajes y es una colecci√≥n de d√≠gitos binarios o bits (0 y 1) que la computadora lee e interpreta y son los √∫nicos idiomas que las computadoras entienden.

Ejemplo: 10110000 01100001

No entendemos muy bien lo que dice ¬øverdad? Por eso, el lenguaje ensamblador nos permite entender mejor a qu√© se refiere √©ste c√≥digo.

Lenguaje ensamblador
El lenguaje ensamblador es el primer intento de sustituci√≥n del lenguaje de m√°quina por uno m√°s cercano al utilizado por los humanos.

Un programa escrito en √©ste lenguaje es almacenado como texto (tal como programas de alto nivel) y consiste en una serie de instrucciones que corresponden al flujo de √≥rdenes ejecutables por un microprocesador.

Sin embargo, dichas m√°quinas no comprenden el lenguaje emsamblador, por lo que se debe convertir a lenguaje m√°quina mediante un programa llamado Ensamblador.

Este genera c√≥digos compactos, r√°pidos y eficientes creados por el programador que tiene el control total de la m√°quina.

Ejemplo: MOV AL, 61h (asigna el valor hexadecimal 61 al registro ‚ÄúAL‚Äù)

Lenguaje de programaci√≥n de alto nivel
Tienen como objetivo facilitar el trabajo del programador, ya que utilizan unas instrucciones m√°s f√°ciles de entender.

Adem√°s, el lenguaje de alto nivel permite escribir c√≥digos mediante idiomas que conocemos (espa√±ol, ingl√©s, etc.) y luego, para ser ejecutados, se traduce al lenguaje de m√°quina mediante traductores o compiladores.

Traductor
Traducen programas escritos en un lenguaje de programaci√≥n al lenguaje m√°quina de la computadora y a medida que va siendo traducida, se ejecuta.

Compilador
Permite traducir todo un programa de una sola vez, haciendo una ejecuci√≥n m√°s r√°pida y puede almacenarse para usarse luego sin volver a hacer la traducci√≥n.

***Clase 4 Preparaci√≥n de la computadora***

Antes de comenzar este curso aseg√∫rate de preparar tu entorno de trabajo para poder hacer todos los ejercicios. A continuaci√≥n te compartir√© los pasos que debes seguir para configurar tu computadora.

Si est√°s usando Windows aseg√∫rate de instalar lo siguiente en tu computadora:

Python 3.7 (o superior)
1. Para obtener el instalador dir√≠gete a https://www.python.org/downloads/
1.png
2. Descarga el instalador y ejec√∫talo en tu computadora.
2.png
3. Habilita la casilla de verificaci√≥n en Install launcher for all users y Add Python 3.8 to PATH. A continuaci√≥n presiona en Install Now. Windows te solicitar√° permisos para instalar Python en tu computadora.
3.png
4. Al finalizar la instalaci√≥n se abrir√° una ventana como la siguiente, en ella deber√°s presionar en la opci√≥n Disable path length limit. Windows te solicitar√° permisos para realizar este cambio.
4.png
Visual Studio Code
En el curso el profesor utiliza Visual Studio Code, un editor de textos que tiene integradas varias herramientas que te ayudar√°n a desarrollar tus ejercicios con facilidad. Para obtenerlo en tu computadora, dir√≠gete a: https://code.visualstudio.com/

4.png
1. Realiza una instalaci√≥n normal de Visual Studio code.
6.png
Una vez instalado se ejecutar√° Visual Studio Code.

2. En Visual Studio Code dir√≠gete al panel de Extensiones, se encuentra en el panel lateral izquierdo. Ah√≠ deber√°s buscar la extensi√≥n llamada Python.
6.png
3. Selecciona la extensi√≥n creada por Microsoft, la identificar√°s por ser similar a la que se muestra en la im√°gen. Una vez seleccionada, inst√°lala
7.png
4. Una vez instalada, reinicia Visual Studio Code.
Listo con esto podr√°s correr los programas que escribas en python en la terminal de Visual Studio Code.

Cuando quieras correr tu programa en la terminal de Visual Studio Code, puedes introducir la direcci√≥n como lo muestra el profesor en el curso o presionar en el bot√≥n ‚ÄúRun Python File in Terminal‚Äù

***Clase 4 Elementos b√°sicos de python***

- Bajo nivel vs alto nivel
    - alto nivel: significa que est√° dise√±ado para los humanos, es decir, que se acerca mucho m√°s al lenguaje natural a la forma en que nos comunicamos
    - bajo nivel: est√° dise√±ado para que lo entienda un m√°quina se parece m√°s a unos y ceros
- General vs dominio espec√≠fico
    - General: significa que tiene todos los primitivos que nos otorga turing para poder implementar o computar cualquier algoritmo
    - Dominio espec√≠fico:  son lenguajes especialidados a aplicaciones espec√≠ficas
- Interpretado vs compilado
    - Interpretado: es decir la m√°quina lo va leyendo y cada instrucci√≥n la va convirtiendo a tiempo real en un lenguaje que pueda entender la m√°quina
    - Compilado: 

- Objetos:
    Tipos:
        - entero, flotantes, booleanos, etc
    - Escalares: 
        que se pueden subdividir
    -No escalares:
        que no se pueden subdividir

***Clase 6 asignaci√≥n de variables***

Las variables son simplemente nombres asociados a espacios en memoria, y los vinculamos a trav√©s del operador de asignaci√≥n
Se lee de derecha a izquierda. Al contrario que la lectura normal.

por ejemplo en explicaci√≥n es as√≠:
a = 2
x = 4
z = (a*x/2)
lo que le decimos ah√≠ es que a tiene el valor de 2, x tiene el valor de 4, y z tiene el resultado de la operaci√≥n entre a y x y divido 2
- a las variables siempre se les da un nombre exacto de lo que significa, ejemplo:

base = 2
altura = 4
area = (base*altura)/2

- si tenemos una variable y esa variable apunta a un lugar de memoria y si nosotros reasignamos esa variable, simplemente pasamos a apuntar a otro lugar
las variables en python:
    - Pueden est√°r compuestas de may√∫sculas, min√∫sculas, n√∫meros (sin comenzar con uno), y el s√≠mbolo _
    - No pueden llamarse como palabras reservadas de python

***Clase 7 Cadenas y entradas***

en cadenas se puede usar los operadores * y +, + lo podemos usar paara concatenar dos cadenas
- len -> nos muestra la longitud o el n√∫mero de caracteres que tiene un string
- indexing (indexaci√≥n) -> podemos ver un dato de un string pas√°ndole la posici√≥n exacta de la cadena
- slicing(rebanadas)
    - my_str[comienzo:final:pasos]
    lo que puede uno hacer con esto es decirle, de ese string muestreme los caracteres que estan desde un posici√≥n a otra o tambi√©n,
    muestreme los caracteres que estan desde un posici√≥n en este n√∫mero de pasos
- Los objetos o tipo de str pueden representarse con comillas simples o comillas dobles "",''
- Operador + tiene diferentes significados seg√∫n el tipo de dato (overloaded). Con cadenas significa concatenaci√≥n
- El operador * es el operador de repetici√≥n con cadenas
- Las cadenas son inmutables
- Entradas:
    - Python tiene la funci√≥n input para recibir datos del usuario del programa
    - Input siempre regresa cadenas, por lo que si queremos usar otro tipo, tenemos que hacer type casting
por ejemplo:
cuando queremos saber el tipo de valor de un dato es con type y es as√≠:
print(type(variable))

- si queremos cambiar el valor que recibe el input es as√≠:
si queremos que reciba un entero es as√≠:
dato = int(input("texto de aviso del input"))
si queremos que reciba un flotante o decimal es as√≠:
dato = float(input("texto"))

***Clase 8 Programas ramificados***

operadores de igualdad:

2==3
2!=3
2>3
2<3
2<=3
2>=3
tabla de verdad
A    |B    |A and B|A or B|Not B|
True |True |True   |True  |False|
True |False|False  |True  |True |
False|True |False  |True  |     |
False|False|False  |False |     |

***Clase 9 iteraciones***

- La mayor√≠a de las tareas computacionales no se pueden lograr con ramificaciones
- Cuando queremos que un programa haga lo mismo varias veces, usamos iteraciones
- Se pueden escribir iteraciones dentro de iteraciones
- Podemos usar break para salir
- Tener cuidado con las iteraciones infinitas

***Clase 10 Bucles for***

Los bucles, en diversos lenguajes de programaci√≥n pueden ser definidos o indefinidos. Los bucles definidos preestablecen las condiciones de la iteraci√≥n por adelantado. Por su parte, los bucles indefinidos establecen la condici√≥n en la que una iteraci√≥n terminar√°. En este √∫ltimo tipo de bucles existe el riesgo de que el bucle se vuelva infinito (cuando la condici√≥n de suspensi√≥n nunca se cumple).

Los bucles definidos se implementan en Python a trav√©s del keyword for. Por su parte, los bucles indefinidos se implementan con el keyword while.

Sin embargo, esta no es la √∫nica forma de implementar bucles definidos. Por ejemplo, Javascript puede implementar un bucle definido mediante el siguiente constructo:

for (i = 0; i <= 10; i++) {
  <expresi√≥n>
}
El bucle se puede leer de la siguiente manera:

Inicializa el bucle en 0
Continua el bucle mientras i sea menor o igual que 10
Incrementa i en uno al final de cada iteraci√≥n
Es importante se√±alar que la expresi√≥n i++ es equivalente a lo que en Python escribir√≠amos como i += 1.

Una segunda forma de crear un bucle definido es iterando en una colecci√≥n de objetos. Esta es la forma que Python utiliza:

for <variable> in <iterable>:
    <expresi√≥n>
El bucle for en Python
En la definici√≥n anterior debemos entender <iterable> como una colecci√≥n de objetos; y la <variable> como el elemento espec√≠fico que se est√° exponiendo mediante el bucle en cada iteraci√≥n.

>>> frutas = ['manzana', 'pera', 'mango']
>>> for fruta in frutas:
        print(fruta)

manzana
pera
mango
Iterables
En Python, un iterable es un objeto que se puede utilizar en un bucle definido. Si un objeto es iterable significa que se puede pasar como argumento a la funci√≥n iter. El iterable que se pasa como par√°metro a la funci√≥n iter
regresa un iterator.

>>> iter('cadena') # cadena
>>> iter(['a', 'b', 'c']) # lista
>>> iter(('a', 'b', 'c')) # tupla
>>> iter({'a', 'b', 'c'}) # conjunto
>>> iter({'a': 1, 'b': 2, 'c': 3}) # diccionario
Todas las llamadas anteriores regresan un objeto de tipo iterator.

¬øQu√© pasa si le pasamos a la funci√≥n iter un objeto que no es iterable? Obtendremos un TypeError que se√±ala que el objeto no es un iterable. Esto es un ejemplo de programaci√≥n defensiva en el que Python verifica el tipo del
objeto antes de proceder al c√≥mputo. ¬°Intentalo en tu consola!

Es importante se√±alar que estos no son los √∫nicos tipos de objetos que pueden ser iterable. Existen gran cantidad de ejemplos en la librer√≠a est√°ndar y, de hecho, casi cualquier objeto se puede convertir en un iterable (pero eso
ya lo veremos cuando hablemos de Python avanzado).

Iterators
Ahora que ya sabemos c√≥mo obtener un iterator, ¬øQu√© podemos hacer con √©l? Un iterator es un objeto que regresa sucesivamente los valores asociados con el iterable.

>>> frutas = ['manzana', 'pera', 'mango']
>>> iterador = iter(frutas)
>>> next(iterador)
manzana
>>> next(iterador)
pera
>>> next(iterador)
mango
Como puedes ver, el iterator guarda el estado interno de la iteraci√≥n, de tal manera que cada llamada sucesiva a next regresa el siguiente elemento. ¬øQu√© pasa una vez que ya no existan m√°s elementos en el iterable? La llamada
a next arrojar√° un error de tipo StopIteration.

¬øC√≥mo implementa Python los bucles definidos?
Ahora ya conocemos todos los elementos necesarios para entender que es lo que sucede en Python cuando ejecutamos un bucle for. Considera nuevamente el siguiente c√≥digo:

>>> frutas = ['manzana', 'pera', 'mango']
>>> for fruta in frutas:
        print(fruta)
Este bucle se puede describir con los conceptos que explicamos previamente:

Python llama internamente la funci√≥n iter para obtener un iterator
Una vez que tiene un iterator llama repetidamente la funci√≥n next para
tener acceso al siguiente elemento en el bucle.
Detiene el bucle una vez que se arroja el error StopIteration.
Bucles for con diccionarios
Para iterar a lo largo de un diccionario tenemos varias opciones:

Ejecutar el bucle for directamente en el diccionario, lo cual nos permite
iterar a lo largo de las llaves del diccionario.
Ejecutar el bucle for en la llamada keys del diccionario, lo cual nos permite
iterar a lo largo de las llaves del diccionario.
Ejecutar el bucle for en la llamada values del diccionario, lo cual nos
permite iterar a lo largo de los valores del diccionario.
Ejecutar el bucle for en la llamada items del diccionario, lo cual nos
permite iterar en una tupla de las llaves y los valores del diccionario.
estudiantes = {
    'mexico': 10,
    'colombia': 15,
    'puerto_rico': 4,
}

for pais in estudiantes:
    ...

for pais in estudiantes.keys():
    ...

for numero_de_estudiantes in estudiantes.values():
    ...

for pais, numero_de_estudiantes in estudiantes.items():
    ...
Modificaci√≥n del comportamiento de un bucle for
Podemos modificar el comportamiento de un bucle for mediante los keywords
break y continue.

break termina el bucle y permite continuar con el resto del flujo de nuestro
programa.

continue termina la iteraci√≥n en curso y continua con el siguiente ciclo de
iteraci√≥n.

Conclusiones
Como pudimos observar, Python implementa los bucles definidos mediante los bucles for. Esta implementaci√≥n nos permite iterar a lo largo de cualquier objeto que sea iterable. Para iterar necesitamos un iterador que nos regresar√°
el siguiente valor en cada iteraci√≥n. Todo esto, Python lo puede hacer por nosotros con el constructo for ... in ....

***Clase 11 Representaci√≥n de flotantes***

La mayor√≠a del tiempo los n√∫meros flotantes (tipo float) son una muy buena aproximaci√≥n de los n√∫meros que queremos calcular con nuestras computadoras. Sin embargo, ‚Äúla mayor√≠a del tiempo‚Äù no significa todo el tiempo, y cuando no se comportan de esta manera puede tener consecuencias inesperadas.

Por ejemplo, trata de correr el siguiente c√≥digo:

x = 0.0
for i in range(10):
    x += 0.1

if x == 1.0:
    print(f'x = {x}')
else:
    print(f'x != {x}')
Es probable que te hayas sorprendido con el resultado. La mayor√≠a de nosotros esperar√≠amos que imprimiera 1.0 en vez de 0.999999999999. ¬øQu√© es lo que pas√≥?.

Para entender qu√© es lo que pas√≥ tenemos que entender que es lo que pasa en la computadora cuando realizamos c√≥mputos con n√∫meros flotantes. Y para eso necesitamos entender n√∫meros binarios.

Cuando aprendiste a contar, lo que en realidad aprendiste es una t√©cnica combinatoria para manipular los siguientes s√≠mbolos que le llamamos n√∫meros: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.

La forma en la que funciona esta t√©cnica es asignando el n√∫mero 10 a la 0 al n√∫mero de la extrema derecha, 10 a la 1 al siguiente, 10 a la 2 al siguiente y as√≠ sucesivamente. De tal manera que el n√∫mero 525 es simplemente la representaci√≥n de (5 * 100) + (2 * 10) + (5 * 1).

Esto nos dice que el n√∫mero de n√∫meros que podemos representar depende de cuanto espacio tengamos. Si tenemos un espacio de 3, podemos representar 1,000 n√∫meros (10 elevado a la 3) o la secuencia del 0 al 999. Si tenemos 4, podemos representar 10,000 (10 elevado a la 4) o la secuencia del 0 al 9,999. De manera general podemos decir que con una secuencia de tama√±o n, podemos representar 10 elevado a la n n√∫meros.

Los n√∫meros binarios funcionan de la misma manera (de hecho cualquier n√∫mero en cualquier base, por ejemplo, octales o hexadecimales). La √∫nica diferencia es cu√°ntos s√≠mbolos tenemos para representar. En binario nada m√°s tenemos 0, 1;
en hexadecimal tenemos 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f.

De esta manera podemos decir que el n√∫mero de la extrema derecha es cantidad_de_simbolos**0, cantidad_de_simbolos**1, cantidad_de_simbolos**2, etc. Por lo que en binario, que nada m√°s tenemos 2 s√≠mbolos, decimos 2**0, 2**1, 2**2, etc. Por ejemplo el n√∫mero binario 101 es la representaci√≥n de (1 * 4) + (0 * 2) + (1 * 1), es decir 5.

Esta representaci√≥n nos permite trabajar con todos los n√∫meros positivos enteros dentro del computador, pero ¬øQu√© hacemos con los negativos y los racionales?.

El caso de los n√∫meros negativos es sencillo: simplemente agregamos un bit adicional que representa el signo y la a√±adimos en la extrema izquierda. Por lo que el n√∫mero 0101 ser√≠a +5 y el n√∫mero 1101 ser√≠a -5.

El caso de los racionales es m√°s complejo. En la mayor√≠a de los lenguajes de programaci√≥n modernos los racionales utilizan una implementaci√≥n llamada punto flotante. ¬øC√≥mo funciona esta representaci√≥n?.

Antes de pasar a binario, vamos a pretender que estamos trabajando con una computadora basada en decimales. Un n√∫mero flotante lo representar√≠amos con un par de enteros: los d√≠gitos significativos y el exponente. Por ejemplo, el n√∫mero 2.345 se representar√≠a como (2345 * 10**-3) o (2345, -3).

El n√∫mero de d√≠gitos significativos determinan la precisi√≥n con la que podemos representar n√∫mero. Por ejemplo si nada m√°s tuvi√©ramos dos d√≠gitos significativos el n√∫mero 2.345 no se podr√≠a representar de manera exacta y tendr√≠amos que convertirlo a una aproximaci√≥n, en este caso 2.3.

Ahora pasemos a la verdadera representaci√≥n interna de la computadora, que es en binario. ¬øC√≥mo representar√≠as el n√∫mero 5/8 o 0.625? Lo primero que tenemos que saber es que 5/8 es en realidad el n√∫mero 5 * 2**-3. Por lo que podr√≠amos decir (101, -11) (recuerda que el n√∫mero 5 es 101 en binario y el 3 es 11).

Regresemos a nuestro problema inicial: ¬øC√≥mo representaremos 1/10 (que escribimos en Python c√≥mo 0.1)? Lo mejor que podemos hacer con cuatro d√≠gitos significativos es (0011, -101) que es equivalente a 3/32 (0.09375). ¬øQu√© tal si tuvi√©ramos cinco d√≠gitos significativos? La mejor representaci√≥n ser√≠a (11001, -1000) que es equivalente a 25/256 (0.09765625). ¬øCu√°ntos d√≠gitos significativos necesitamos entonces? Un n√∫mero infinito. No existe ning√∫n n√∫mero que cumpla con la siguiente ecuaci√≥n: sim * 2**-exp.

En la mayor√≠a de las implementaciones de Python tenemos 53 bits de precisi√≥n para n√∫meros flotantes. As√≠ que los d√≠gitos significativos para representar el n√∫mero 0.1 es igual a:

11001100110011001100110011001100110011001100110011001 que es equivalente al n√∫mero decimal: 0.1000000000000000055511151231257827021181583404541015625

Muy cercano a 1/10 pero no exactamente 1/10. Ahora ya sabemos la raz√≥n de esa respuesta tan extra√±a. Hay muy pocas situaciones en la que 1.0 es aceptable, pero 0.9999999999999999 no. Pero ¬øCu√°l es la moraleja de esta historia?

Hasta ahora hemos verificado igualdad con el operador ==. Sin embargo, cuando estamos trabajando con flotantes es mejor asegurarnos que los n√∫meros sean aproximados en vez de id√©nticos. Por ejemplo x < 1.0 and x > 0.99999.

***Clase 12 Enumeraci√≥n exhaustiva***

- Tambi√©n llamado "adivina y verifica"
- Las computadoras actuales son muy muy r√°pidas
- Uno de los primeros algoritmos que debes tratar

***Clase 13 Aproximaci√≥n de soluciones***

- Similar a enumeraci√≥n exhaustiva, pero no necesita una respuesta exacta
- Podemos aproximar soluciones con un margen de error que llamaremos epsilon 
- abs() -> funci√≥n que nos regresa el valor absoluto de un n√∫mero
- los algoritmos dependen del hardware

***Clase 14 B√∫squeda binaria***

- Cuando la respuesta se encuentra en un conjunto ordenado, podemos usar la b√∫squeda binaria
- Es altamente eficiente, pues corta el espacio de b√∫squeda en dos por cada partici√≥n 
cuando hay un conjunto ordenado la b√∫squeda binaria si funciona

Lo aplicado en esta clase se denomina M√©todos Num√©ricos, el metodo usado en la clase es conocido como m√©todo de la bisecci√≥n, es un tipo de b√∫squeda incremental en el que el intervalo se divide siempre a la mitad.
Existen diversos m√©todos que tiene una mejor convergencia para la aproximaci√≥n a la soluci√≥n, el mas conocido es el metodo newtoh raphson.

Pueden revisar este libro si les interesa aprender mas sobre M√©todos Num√©ricos


***Clase 15 funciones y abstracci√≥n***

- La abstracci√≥n significa que no necesitamos entender como funciona algo internamente para usarlo
- Decomposici√≥n: 
    - Permite dividir el c√≥digo en componentes que colaboran con un fin en com√∫n
    - Se puede pensar como mini programas dentro de un programa mayor

***Clase 16 Alcance***

- tambi√©n podemos pasar funciones como argumentos
- es entender como se va ejecutar una funci√≥n, paso a paso

***Clase 17 Especificaciones del c√≥digo***

los docstrings -> es como un comentario que se deja en un c√≥digo explicando variedad de cosas como por ejemplo qui√©n lo hizo, cu√°ndo lo hizo, para que lo hizo,
cual es su finalidad, en donde m√°s se est√° usando, etc.

para saber como funciona una funci√≥n lo podemos hacer con help, as√≠:
help(nombre_de_la_funci√≥n)
help(suma)
def suma(a,b):
    """ suma dos valores a y b
    le estamos diciendo que estamos esperando un parametro(param) que debe ser entero(int(a)) y puede ser cualquier entero
    param int a cualquier entero
    le estamos diciendo que estamos esperando un parametro(param) que debe ser entero(int(b)) y puede ser cualquier entero
    param int b cualquier entero
    le decimos que es lo que regresa esta funci√≥n
    returns la sumatoria de a y b
    """
    total a+b
    return total

***Clase 18 Recursividad***

- Algor√≠tmica: Una forma de crear soluciones usando el principio de "divide y vencer√°s"
- Program√°tica: Una t√©cnica program√°tica mediante la cual una funci√≥n se llama a s√≠ misma

Desconoc√≠a totalmente que Python tuviera un l√≠mite de recursividad. Para conocerlo hay que importar la librer√≠a sys:

>>> import sys
>>> print(sys.getrecursionlimit())
1000
Para modificar ese l√≠mite

sys.setrecursionlimit(n) # n es el nuevo l√≠mite a establecer


***Clase 19 Finobacci y la recursividad***
La secuencia de Fibonacci es una funci√≥n matem√°tica que se define recursivamente. En el a√±o 1202, el matem√°tico italiano Leonardo de Pisa, tambi√©n conocido como Fibonacci, encontr√≥ una f√≥rmula para cuantificar el crecimiento que ciertas poblaciones experimentan.

Imagina que una pareja de conejos nace, un macho y una hembra, y luego son liberados. Imagina, tambi√©n, que los conejos se pueden reproducir hasta la edad de un mes y que tienen un periodo de gestaci√≥n tambi√©n de un mes. Por √∫ltimo imagina que estos conejos nunca mueren y que la hembra siempre es capaz de producir una nueva pareja (un macho y una hembra). ¬øCu√°ntos conejos existir√°n al final de seis meses?

Una forma de visualizar este crecimiento es mir√°ndolo de forma tabular:

Mes	Hembras
0	1
1	1
2	2
3	3
4	5
5	8
6	13
Un punto importante a considerar es que para el mes n > 1, hembras(n) = hembras(n - 1) + hembras(n - 2).

Como podemos ver, tenemos una definici√≥n distinta a la de factorial que vimos anteriormente. En espec√≠fico, tenemos dos casos base (0 y 1) y tenemos dos llamadas recursivas (hembras(n - 1) + hembras(n - 2)).

Podemos crear una soluci√≥n recursiva de manera sencilla:

def fibonacci(n):
    if n == 0 or n == 1:
        return 1

    return fibonacci(n - 1) + fibonacci(n - 2)
Aunque la definici√≥n es muy sencilla, es tambi√©n bastante ineficiente. En los siguientes cursos de la serie de pensamiento computacional veremos como calcular exactamente la eficiencia de este algoritmo y c√≥mo optimizarlo. De mientras, plat√≠canos si conoces alguna otra definici√≥n recursiva.

***Clase 20 Funciones como objetos***

Funciones como objetos
Una de las caracter√≠sticas m√°s poderosas de Python es que todo es un objeto, incluyendo las funciones. Las funciones en Python son ‚Äúciudadanos de primera clase‚Äù.

Esto, en sentido amplio, significa que en Python las funciones:

Tienen un tipo
Se pueden pasar como argumentos de otras funciones
Se pueden utilizar en expresiones
Se pueden incluir en varias estructuras de datos (como listas, tuplas,
diccionarios, etc.)
Argumentos de otras funciones
Hasta ahora hemos visto que las funciones pueden recibir par√°metros para realizar los c√≥mputos que definen. Algunos de los tipos que hemos pasado son tipos simples como cadenas, n√∫meros, listas, etc. Sin embargo, tambi√©n pueden recibir funciones para crear abstracciones m√°s poderosas. Veamos un ejemplo:

def multiplicar_por_dos(n):
    return n * 2

def sumar_dos(n):
    return n + 2

def aplicar_operacion(f, numeros):
    resultados = []
    for numero in numeros:
        resultado = f(numero)
        resultados.append(resultado)

>>> nums = [1, 2, 3]
>>> aplicar_operacion(multiplicar_por_dos, nums)
[2, 4, 6]

>>> aplicar_operacion(sumar_dos, nums)
[3, 4, 5]
Funciones en expresiones
Una forma de definir una funci√≥n en una expresi√≥n es utilizando el keyword lambda. lambda tiene la siguiente sintaxis: lambda <vars>: <expresion>.

Otro ejemplo interesante es que las funciones se pueden utilizar en una expresi√≥n directamente. Esto es posible ya que como lo hemos platicado con anterioridad, en Python las variables son simplemente nombres que apuntan a un objeto (en este caso a una funci√≥n). Por ejemplo:

sumar = lambda x, y: x + y

>>> sumar(2, 3)
5
Funciones en estructuras de datos
Las funciones tambi√©n se pueden incluir en diversas estructuras que las permiten almacenar. Por ejemplo, una lista puede guardar diversas funciones a aplicar o un diccionario las puede almacenar como valores.

def aplicar_operaciones(num):
    operaciones = [abs, float]

    resultado = []
    for operacion in operaciones:
        resultado.append(operacion(num))

    return resultado

>>> aplicar_operaciones(-2)
[2, -2.0]
Como pudimos ver, las funciones son objetos muy vers√°tiles que nos permiten tratarlas de diversas maneras y que nos permiten a√±adir capas adicionales de abstracci√≥n a nuestro programa.

Comp√°rtenos c√≥mo te imaginas que estas capacidades de Python te pueden ayudar a escribir mejores programas.
ver la el archivo clase20.py, ah√≠ se ejecutaron las funciones que est√°n en estos apuntes que corresponden a la clase 20

***Clase 21 Tuplas***

- Son secuencias inmutables de objetos
- A diferencia de las cadenas pueden contener cualquier tipo de objeto
- Pueden usarse para resolver varios valores en una funci√≥n

***Clase 22 Rangos***

- Representan una secuencia de enteros
- range(comienzo,fin,pasos)
- Al igual que las cadenas y las tuplas, los rangos son inmutables
- Muy eficientes en uso de memoria y normalmente usado en for loops
- Tener en cuenta que cuando uno pide un rango siempre el n√∫mero final que uno le indica no es hasta donde va, si no que va hasta el n√∫mero antes del que uno le indic√≥, ejemplo:
my_range = range(1,5)
esto lo que va imprimir es desde el n√∫mero 1 hasta el 4 y siempre es as√≠, como dije antes, imprime hasta el n√∫mero anterior al indicado

***Clase 23 Listas y mutabilidad***

- Son secuencias de objetos, pero a diferencia de las tuplas, s√≠ son mutables, modificables
- Cuando modificas una lista, pueden existir efectos secundarios(sid effects)
- Es posible iterar con ellas
- Para modificar una lista podemos:
    - Asignar v√≠a indice (my_list[9] = 3)
    - Utilizar los metodos de la lista(append, pop, remove, insert, etc.)
- Clonaci√≥n de listas:
    - Casi siempre es mejor clonar una lista en lugar de mutarla
    - Para clonar una lista podemos usar rebanadas (slices) o la funci√≥n list
- List comprenhension:
    - Es una forma concisa de aplicar operaciones a los valores de una secuencia
    - Tambi√©n se pueden aplicar condiciones para filtrar

#para generar una lista con un rango lo hacemos as√≠:
my_list = list(range(10))

https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

***Clase 24 Diccionarios***

- Son como listas, pero en lugar de usar indices usan llaves
- No tienen orden interno
- Los diccionarios son mutables, es decir, modificables
- Pueden iterarse

IMPORTANTE

https://www.datacamp.com/community/tutorials/python-dictionary-comprehension

***Clase 25 Pruebas de caja negra***

- Se basan en una especificaci√≥n de la funci√≥n o el programa
- Prueba inputs y outputs
- Unit testing o integration testing

TDD o Test Driven Development es una metodolog√≠a donde hacemos todo al rev√©s. Por un momento vamos a dejar de programar para dedicarnos a escribir las pruebas.

Pero, ¬øc√≥mo vamos a saber lo que debemos probar si ni siquiera hemos escrito el c√≥digo? Muy buena pregunta. Eso es exactamente lo que vamos a descubrir a continuaci√≥n.

Objetivo: agilizar nuestro desarrollo
Las pruebas son c√≥digo que escribimos para comprobar que otra parte del c√≥digo funciona correctamente. Sin embargo, no debemos olvidar que podemos caer en muy malas pr√°cticas al escribir nuestro c√≥digo sin saber exactamente lo que debe hacer, qu√© resultados debemos conseguir o cu√°ndo deben saltar las alarmas.

En ocasiones puede parecer que es m√°s demorado. Pero, as√≠ como toda buena pr√°ctica, esto es solo al principio, solo es un primer ‚Äúobst√°culo‚Äù que debemos superar para conseguir muchos beneficios.

A la larga, seguir estas metodolog√≠as y buenas pr√°cticas nos ahorra tiempo y esfuerzo en errores que debemos resolver. Ser√° mucho m√°s f√°cil implementar nuevas caracter√≠sticas y evitaremos escribir c√≥digo in√∫til que vamos a utilizar.

Gracias a TDD podemos agilizar nuestro proceso de creaci√≥n de c√≥digo. Nos preocupamos m√°s por el qu√© y el por qu√© antes del c√≥mo. Todo el c√≥digo que necesitamos para implementar eso que planeamos con las pruebas ser√° problema un poco m√°s adelante. Por ahora, lo que importa es asegurarnos que estamos resolviendo los problemas correctos.

C√≥mo funciona: ciclo de vida de las pruebas
TDD y el concepto de Black Box
Nuestra metodolog√≠a de pruebas funciona muy parecido a un concepto de sistemas y f√≠sica que conocemos como Black Box: Estudiamos o trabajamos a partir de las entradas (inputs) y las salidas o respuestas que produce o deber√≠a producir nuestro sistema (outputs).

Caja negra (sistemas) - Wikipedia.
Con nuestras pruebas es igual. Definimos los argumentos que le enviamos a ‚Äúla caja negra‚Äù y las posibles respuestas que debemos obtener dependiendo de las combinaciones de argumentos.

El desarrollo de nuestras pruebas es el siguiente:

Definimos los objetivos de nuestra prueba y escribimos su posible implementaci√≥n. Nuestras pruebas deben fallar al principio porque, claramente, todav√≠a no hemos programado el c√≥digo que les permita funcionar correctamente. ü§î
Programamos el c√≥digo necesario para pasar las pruebas. üòé
Redefinimos los objetivos. Podemos a√±adir nuevos casos de uso y refactorizar nuestro c√≥digo para mejorar la aplicaci√≥n. üòè
Herramientas de TDD
No hay una herramienta como tal para implementar la metodolog√≠a de TDD. M√°s bien, existen herramientas que nos ayudan a escribir y correr nuestras pruebas de forma automatizada.

Aqu√≠ algunas de las herramientas y frameworks m√°s populares para diferentes lenguajes:

JUnit para Java: Es gratuito y open source. Tiene muy buen soporte, mantenimiento y est√° en constante mejora con nuevas versiones. Nos permite probar EJBs, servlets y programas multihilo pero no hace pruebas unitarias en interfaces Swing, JSPs o HTML. Nos proporciona muy buena DX o experiencia a los desarrolladores ya que se integra muy bien con IntelliJ. Github.com/Junit-team.
Jest para JavaScript: Existen muchas alternativas pero, Jest tiene una comunidad muy grande que ha creado m√°s herramientas para mejorar a√∫n m√°s la experiencia de los desarrolladores. Tambi√©n es open source y tiene muy buen mantenimiento por sus creadores, de Facebook. Adem√°s, se integra muy bien con herramientas como React, Vue y Angular; funciona tanto del lado del cliente (frontend) como de lado del servidor (frontend y backend). Github.com/Facebook/Jest.
En Python: Como te dije antes, TDD es una metodolog√≠a y la podemos aplicar con cualquier herramienta. Por supuesto, existen librer√≠as nativas o instalables que facilitan el desarrollo y automatizaci√≥n de pruebas en Python como unittest, pytest o Hypothesis.
MiniTest para Ruby: Tambi√©n dispone de algunas herramientas nativas que nos dan algunas ayudas para escribir nuestras pruebas m√°s f√°cilmente. Adem√°s, se integran muy bien con Rails y las gemas m√°s populares de Ruby: MiniTest.
Omit√≠ algunas herramientas y lenguajes que tambi√©n pueden ser muy √∫tiles. Si quieres, puedes decirme tus favoritos en los comentarios üòÉ.

https://platzi.com/blog/que-es-y-como-funciona-tdd/

***Clase 26 Pruebas caja de cristal***

El testing tambien es un campo interesante,
Aqui la lista de los ** 7 principios de Testing ** de acuerdo al libro de ISTQB.

1 Las pruebas muestran la presencia de defectos
Significa que las pruebas pueden demostrar que EXISTEN problemas, pero no que los problemas NO EXISTEN.
El objetivo principal de llevar a cabo una prueba es para detectar defectos. Trabajando bajo la premisa de que cada producto contiene defectos de alg√∫n tipo, una prueba que revela los errores es generalmente mejor que una que no lo hace. Todas las pruebas por lo tanto, deben ser dise√±ados para revelar tantos errores como sea posible

2 Las pruebas exhaustivas son imposibles
Las pruebas exhaustivas tratan de cubrir todas las combinaciones posibles de datos en el software, a fin de garantizar que ninguna situaci√≥n puede surgir, una vez probado el software se ha liberado. Excepto en aplicaciones muy simples, el n√∫mero de combinaciones posibles de datos es demasiado alta, es m√°s eficaz y eficiente que los ingenieros de pruebas se centren en las funcionalidades de acuerdo a riesgos y prioridades.

3 Pruebas tempranas.
Un producto (incluyendo los documentos, tales como la especificaci√≥n del producto) se puede probar tan pronto como se ha creado. ISTQB recomienda probar un producto tan pronto como sea posible, corregir los errores m√°s r√°pidamente posible. Los estudios han demostrado que los errores identificados al final del proceso de desarrollo por lo general cuestan m√°s para resolver.
Por ejemplo: un error encontrado en las especificaciones puede ser bastante sencillo de solucionar. Sin embargo, si ese error se transfiere a la codificaci√≥n de software, una vez descubierto el error puede ser muy costoso y consume tiempo.

4 Agrupamiento de Defectos
Los estudios sugieren que los problemas en un elemento de software tienden a agruparse en torno a un conjunto limitado de m√≥dulos o √°reas. Una vez que estas √°reas han sido identificadas, los administradores eficientes de prueba son capaces de enfocar las pruebas en las zonas sensibles, mientras que siguen buscando a los errores en los m√≥dulos de software restantes. Me recuerda al 80/20.

5 La paradoja del ‚ÄúPesticida‚Äù
Al igual que el sobre uso de un pesticida, un conjunto de pruebas que se utilizan repetidamente en el disminuir√° en su eficacia. Usando una variedad de pruebas y t√©cnicas expondr√° una serie de defectos a trav√©s de las diferentes √°reas del producto.

6 La prueba es dependiente del contexto
Las mismas pruebas no se deben aplicar en todos los √°mbitos. Distintos productos de software tienen diferentes requisitos, funciones y prop√≥sitos. Una prueba dise√±ada para realizarse en un sitio web, por ejemplo, puede ser menos eficaz cuando se aplica a una aplicaci√≥n de intranet. Una prueba dise√±ada para una forma de pago con tarjeta de cr√©dito puede ser innecesariamente rigurosa si se realiza en un foro de discusi√≥n.
En general, cuanto mayor es la probabilidad y el impacto de los da√±os causados ‚Äã‚Äãpor el software fallado, mayor es la inversi√≥n en la realizaci√≥n de pruebas de software.

7 La falacia de ausencia de errores
Declarar que una prueba no ha descubierto ning√∫n error no es lo mismo que declarar que el software es ‚Äúlibre de errores‚Äù. Con el fin de garantizar que los procedimientos adecuados de software de prueba se lleva a cabo en todas las situaciones, los evaluadores deben asumir que todo el software contiene algunos (aunque disimulada) errores.

***Clase 27 Debugging***
Reglas generales
- No te molestes con el debugger, aprende a usar el print statement
- Estudia los datos disponibles
- Utiliza los datos para crear hip√≥tesis y experimentos. M√©todo cientifico
- Ten una mente abierta. Si entendieras el programa, probablemente no habr√≠an bugs
- Lleva un registro de lo que has tratado, preferentemente en la forma de tests
- Debugear es un proceso de b√∫squeda. Cada prueba debe acotar el espacio de b√∫squeda
- B√∫squeda binaria con print statement
- Encuentra a los sospechoso comunes
- En lugar de preguntarte por qu√© un programa no funciona, preg√∫ntate por qu√© est√° funcionando de esta manera
- Es posible que el debug no se encuentre donde crees que est√°
- Expl√≠cale el problema a otra persona. De preferencia que no tenga contexto
- Lleva un registro de lo que has tratado, preferentemente en forma de tests
- Vete a dormir

***Clase 28 Manejo de excepciones****

- Son muy comunes en la programaci√≥n, no tiene nada de excepcional
- Las excepciones de python normalmente se relacionan con errores de sem√°ntica
- Se pueden crear excepciones propias
- Cuando una excepci√≥n no se maneja(unhandled exception), el programa termina en error
- Las excepciones se maneja con los keywords: try, except, finally
- Se pueden usar tambi√©n para ramificar programas
- No debe manejarse de manera silenciosa(por ejemplo, con print statements)
- Para colocar tu propia excepci√≥n utiliza el keyword raise

Excepciones comunes:
ImportError : una importaci√≥n falla;
IndexError : una lista se indexa con un n√∫mero fuera de rango;
NameError : se usa una variable desconocida ;
SyntaxError : el c√≥digo no se puede analizar correctamente
TypeError : se llama a una funci√≥n en un valor de un tipo inapropiado;
ValueError : se llama a una funci√≥n en un valor del tipo correcto, pero con un valor inapropiado

***Clase 29 Excepciones y controlde flujo***

Excepciones como control de flujo
Hasta ahora hemos visto como las excepciones nos permiten controlar los posibles errores que pueden ocurrir en nuestro c√≥digo. Sin embargo, dentro de la comunidad de Python tienen otro uso: control de flujo.

En este momento ya debes estar familiarizado con las estructuras de control flujo que ofrece Python (if... elif...else); entonces, ¬øpor qu√© es necesaria otra modalidad para controlar el flujo? Una raz√≥n muy espec√≠fica: el principio EAFP (easier to ask for forgiveness than permission, es m√°s f√°cil pedir perd√≥n que permiso, por sus siglas en ingl√©s).

El principio EAFP es un estilo de programaci√≥n com√∫n en Python en el cual se asumen llaves, √≠ndices o atributos v√°lidos y se captura la excepci√≥n si la suposici√≥n resulta ser falsa. Es importante resaltar que otros lenguajes de programaci√≥n favorecen el principio LBYL (look before you leap, revisa antes de saltar) en el cual el c√≥digo verifica de manera expl√≠cita las precondiciones antes de realizar llamadas.

Veamos ambos estilos:

# Python

def busca_pais(paises, pais):
    &quot;&quot;&quot;
    Paises es un diccionario. Pais es la llave.
    Codigo con el principio EAFP.
    &quot;&quot;&quot;
    
    try:
        return paises[pais]
    except KeyError:
        return None
// Javascript

/**
* Paises es un objeto. Pais es la llave.
* Codigo con el principio LBYL.
*/
function buscaPais(paises, pais) {
  if(!Object.keys(paises).includes(pais)) {
    return null;
  }

  return paises[pais];
}
Como puedes ver, el c√≥digo de Python accede directamente a la llave y √∫nicamente si dicho acceso falla, entonces se captura la excepci√≥n y se provee el c√≥digo necesario. En el caso de JavaScript, se verifica primero que la llave exista en el objeto y √∫nicamente con posterioridad se accede.

Es importante resaltar que ambos estilos pueden utilizarse en Python, pero el estilo EAFP es mucho m√°s "pythonico".

***Clase 30 Afirmaciones***

- Programaci√≥n defensiva
- Pueden usarse para verificar que los tipos sean correctos en una funci√≥n
- Tambi√©n sirven para debuguear
- Las afirmaciones es muy sencilla, necesitamos usar el keyword assert, dar una expresi√≥n booleana, es decir una condici√≥n que eval√∫e
a verdadero o falso y agregar un mensaje, el cual accedemos a √©l cuando terminamos la ejecuci√≥n